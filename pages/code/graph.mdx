# 图论：从橙色到黑色
## 1.存图
### 1.1 邻接矩阵
记 $f[i][j]$ 为 $i$ 到 $j$ 的有向边的边权（无向边建两次）。

时间：$O(n^2)$  空间： $O(n^2)$

优点：

- 容易理解
- 简单明了

缺点：

- 炸时间，炸空间
- 无法处理重边

### 1.2 邻接表（ low版 ）

既然无法处理重边，那么我们就给数组**改进一下**！

记 $f[i][k]$ 为 $i$ 出发的第 $k$ 条有向边的边权（无向边建两次），$num[i]$ 表示从 $i$ 出发的有向边的数量。

时间：$O(m)$  空间： $O(n^2)$

优点：
- 可以处理重边

缺点：

- 炸空间

### 1.3 邻接表（ vector ）

可以发现，刚才的数组中有很多空间是浪费的，原因是我们不知道数组要开多大。

那么，我们就可以用 ```vector```——可变数组来节省空间。

```cpp
struct edge{
	int v,w;
};
vector<edge> g[MAXN];

void add(int u, int v, int w)
{
	g[u].push_back((edge){v,w});
}
```

$g[u][i]$ 表示从 $u$ 出发的第 $i$ 条边， $v$ 表示这条边的终点， $w$ 表示这条边的边权。

遍历时便可以直接```for(int i=0; i<g[u].size(); i++) {edge e=g[u][i]; /*do something*/}```。

优点：
- 可以处理重边
- 易于编写
- 遍历方便

缺点：

- 不开 O2 时常数太大

### 1.4 邻接表（链式前向星）

```cpp
struct edge{
	int u,v,w,nxt;
};
edge e[MAXE];
int cnt=0,head[MAXN];
void add(int u, int v, int w)
{
	e[++cnt]=(edge){u,v,w,head[u]};
    head[u]=cnt;
}
```
$head[u]$ 表示从 $u$ 出发的最后一条边， $u$ 表示这条边的起点， $v$ 表示这条边的终点， $w$ 表示这条边的边权， $nxt$ 表示这个点出发的下一条边。

遍历时便可以直接```for(int i=head[u]; i; i=e[i].next) {edge ed=e[i]; /*do something*/}```。

优点：
- 可以处理重边
- 手写常数小
- 遍历方便

缺点：

- 码量较大

## 2.__短路问题
### 2.0 写在前头
> 由于```Dijkstra```在比赛中实在太常用了，而且基本不会被卡，所以下面的代码都用这一种算法，并且用1.3的方式存图。

### 2.1 最短路

非常基础，所以不做过多说明。思想是贪心。

算法：Dijkstra

定义：
```cpp
struct point{
	int x;
	int step;
	bool operator< (const point & rhs) const
	{
		return rhs.step<step;
	}
};
priority_queue<point> pq;
int vis[50001];
int dis[50001];
```
核心代码：
```cpp
int dijkstra(int st, int ed)
{
	memset(dis,0x7f,sizeof(dis));
    memset(vis,0,sizeof(vis));
	pq.push((point){
		st,0
	});
	dis[st]=0;
	while(!pq.empty())
	{
		point u=pq.top();pq.pop();
		if(vis[u.x]) continue;
		vis[u.x]=1;
		for(int i=0; i<g[u.x].size(); i++)
		{
			int v=g[u.x][i].v;
			if(dis[v]>dis[u.x]+g[u.x][i].w)
			{
				dis[v]=dis[u.x]+g[u.x][i].w;
				pq.push((point){
					v,dis[v]
				});
                        
			}
		}
	}
	return dis[ed];
}
```
算法：BF

思想：对于每个点松弛一轮。复杂度O(nm)。

- 优化1:队列

  > 很明显有很多松弛没有必要，所以可以开个队列记录一下。

- 优化2:判重。
	
	> 很明显已经在队列里的点再进一次队列没有必要。

至此，我们已经完成了SPFA算法（
- 优化3:SPFA优化集锦
```
堆优化：将队列换成堆，与 Dijkstra 的区别是允许一个点多次入队。在有负权边的图可能被卡成指数级复杂度。

栈优化：将队列换成栈（即将原来的 BFS 过程变成 DFS），在寻找负环时可能具有更高效率，但最坏时间复杂度仍然为指数级。

SLF 优化：每次将入队结点距离和队首比较，如果更大则插入至队尾。

Hack：使用链套菊花的方法，在链上用几个并列在一起的小边权边就能欺骗算法多次进入菊花。

SLF 带容错：每次将入队结点距离和队首比较，如果比队首大超过一定值则插入至队尾。

Hack：如果边权之和很小的话似乎没有什么很好的办法。所以卡法是卡 SLF 的做法，并开大边权，总和最好超过 1e12 。

mcfx 优化（thanks to mcfx and yfzcsc）：在第 [L,R] 次访问一个结点时，将其放入队首，否则放入队尾。通常取 L=2,R=根号V 。

Hack：网格图表现优秀，但是菊花图表现很差。P.S. 此优化与 SLF 带容错一起使用有更好的效果，可以使所需要的边权上升许多。

SLF + swap：每当队列改变时，如果队首距离大于队尾，则交换首尾

Hack: 与卡 SLF 类似，外挂诱导节点即可。
```
> 其实从原理上分析，所有 spfa 的优化都是为了使队列接近优先队列。然而，我们知道维护一个优先队列在目前来说是需要 log 的复杂度的，所以低于该复杂度的 一定能 Hack。
### 2.2 次短路
在最短路的基础上，想到把 $dis$ 数组多开一维，用 $dis[i][1]$ 表示到 $i$ 这个点的最短路，用 $dis[i][2]$ 表示到 $i$ 这个点的次短路。

定义：
```cpp
struct point{
	int x;
	int step;
	bool operator< (const point & rhs) const
	{
		return rhs.step<step;
	}
};
priority_queue<point> pq;
int vis[50001];
int dis[50001][3];
```
代码：
```cpp
int dijkstra_2th(int st, int ed)
{
	pq.push((point){
		st,0
	});
	dis[st][1]=0;
	while(!pq.empty())
	{
		point u=pq.top();pq.pop();
		
		vis[u.x]=1;
		for(int i=0; i<g[u.x].size(); i++)
		{
			int v=g[u.x][i].v;
            bool flg=0;
			if(u.step+g[u.x][i].w<dis[v][1])
			{
				dis[v][2]=dis[v][1];
				dis[v][1]=u.step+g[u.x][i].w;
				flg=1;
			}
			if(u.step+g[u.x][i].w>dis[v][1] && u.step+g[u.x][i].w<dis[v][2])
			{
				dis[v][2]=u.step+g[u.x][i].w;
				flg=1;
			}
			if(dis[u.x][2]+g[u.x][i].w<dis[v][2])
			{
				dis[v][2]=dis[u.x][2]+g[u.x][i].w;
				flg=1;
			}
			if(flg)
			{
				pq.push((point){v,dis[v][1]});
			}
		}
	}
	return dis[ed][2];
}
```

### 2.3 k短路
这里只讨论k很小的情况。

很显然，将 $dis$ 数组多开一维，用 $dis[i][j]$ 表示到 $i$ 这个点的第 $j$ 短路。

每次松弛操作就是对 $dis$ 数组进行插入排序。

代码略。

### 2.4 指定边的最短路

很显然，设整张图起点为 $s$ ，终点为 $t$ ，指定边起点为 $u$ ，终点为 $v$ ，边权为 $w$ ，最后要求的答案就是```dijkstra(s,u)+w+dijkstra(v,t)```。

代码略。

## 3.环

### 3.1 全图最小环

算法：```Floyd```

时间复杂度：$O(n^3)$

具体实现：
```cpp
for(int k=1; k<=n; k++)
{
	for(int i=1; i<k; i++)
		for(int j=i+1; j<k; j++)
			ans=min(ans,dp[i][j]+g[i][k]+g[k][j]);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]),dp[j][i]=dp[i][j];
}
```
